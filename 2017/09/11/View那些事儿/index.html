<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="http://7xjtan.com1.z0.glb.clouddn.com/favicon.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="http://7xjtan.com1.z0.glb.clouddn.com/favicon.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="http://7xjtan.com1.z0.glb.clouddn.com/favicon.png?v=5.1.4">


  <link rel="mask-icon" href="http://7xjtan.com1.z0.glb.clouddn.com/favicon.png?v=5.1.4" color="#222">





  <meta name="keywords" content="Android," />










<meta name="description" content="[TOC] 前言View是我们开发中再熟悉不过的一个组件了，几乎任何需求的开发实现都离不开它。那么今天今天就好好梳理一下View的基础内容，常用自定义方法，事件分发等知识。  看了不少Android的源码，总结出一点心得： 所谓的代码简洁不是代码量少，而是逻辑简单明了。 常常看到源码中会有不少重复判断的地方，或者说可以合并起来的判断语句，但是Google工程师都是分开处理的，这就不得不让我疑惑了。">
<meta name="keywords" content="Android">
<meta property="og:type" content="article">
<meta property="og:title" content="View那些事儿">
<meta property="og:url" content="https://bornbeauty.github.io/2017/09/11/View那些事儿/index.html">
<meta property="og:site_name" content="Jimbo`s Blog">
<meta property="og:description" content="[TOC] 前言View是我们开发中再熟悉不过的一个组件了，几乎任何需求的开发实现都离不开它。那么今天今天就好好梳理一下View的基础内容，常用自定义方法，事件分发等知识。  看了不少Android的源码，总结出一点心得： 所谓的代码简洁不是代码量少，而是逻辑简单明了。 常常看到源码中会有不少重复判断的地方，或者说可以合并起来的判断语句，但是Google工程师都是分开处理的，这就不得不让我疑惑了。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://7xjtan.com1.z0.glb.clouddn.com/WechatIMG268.jpeg">
<meta property="og:image" content="http://7xjtan.com1.z0.glb.clouddn.com/Jietu20171206-195250.jpg">
<meta property="og:updated_time" content="2018-04-28T02:27:51.441Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="View那些事儿">
<meta name="twitter:description" content="[TOC] 前言View是我们开发中再熟悉不过的一个组件了，几乎任何需求的开发实现都离不开它。那么今天今天就好好梳理一下View的基础内容，常用自定义方法，事件分发等知识。  看了不少Android的源码，总结出一点心得： 所谓的代码简洁不是代码量少，而是逻辑简单明了。 常常看到源码中会有不少重复判断的地方，或者说可以合并起来的判断语句，但是Google工程师都是分开处理的，这就不得不让我疑惑了。">
<meta name="twitter:image" content="http://7xjtan.com1.z0.glb.clouddn.com/WechatIMG268.jpeg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://bornbeauty.github.io/2017/09/11/View那些事儿/"/>





  <title>View那些事儿 | Jimbo`s Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jimbo`s Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://bornbeauty.github.io/2017/09/11/View那些事儿/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jimbo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jimbo`s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">View那些事儿</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-11T20:58:16+00:00">
                2017-09-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>[TOC]</p>
<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p><code>View</code>是我们开发中再熟悉不过的一个组件了，几乎任何需求的开发实现都离不开它。那么今天今天就好好梳理一下View的基础内容，常用自定义方法，事件分发等知识。</p>
<blockquote>
<p>看了不少Android的源码，总结出一点心得： <strong>所谓的代码简洁不是代码量少，而是逻辑简单明了。</strong> 常常看到源码中会有不少重复判断的地方，或者说可以合并起来的判断语句，但是Google工程师都是分开处理的，这就不得不让我疑惑了。随着每一次的思考，今天突然发现，原来我一直在享受这样的写的便利，就是每一段代码判断都只做一件事，逻辑清晰明了~</p>
</blockquote>
<h4 id="从LayoutInflater讲起"><a href="#从LayoutInflater讲起" class="headerlink" title="从LayoutInflater讲起"></a>从LayoutInflater讲起</h4><p>为什么讲View要先讲<code>LayoutInflater</code>呢？因为View的加载都是通过<code>LayoutInflater</code>的<code>inflate(...)</code>方法进行的。可是我们在Activity中使用<code>setContentView(int layoutID)</code>也调用这个方法了吗？答案是肯定的。</p>
<p><code>setContentView()</code>的源码是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void setContentView(int resId) &#123;</span><br><span class="line">    ensureSubDecor();</span><br><span class="line">    ViewGroup contentParent = (ViewGroup) mSubDecor.findViewById(android.R.id.content);</span><br><span class="line">    contentParent.removeAllViews();</span><br><span class="line">    LayoutInflater.from(mContext).inflate(resId, contentParent);</span><br><span class="line">    mOriginalWindowCallback.onContentChanged();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：如果你继承的是AppCompatActivity的话会追踪到一个<code>AppCompatDelegate</code>类，这个不用管 直接看他的实现类的对应方法就行了</p>
</blockquote>
<p>LayoutInflater.inflate()方法的作用也很清晰，就是将XML文件中的一个布局加载转化成一个View类对象。究竟这个过程是如何完成的，我们一步一步的看一下。</p>
<h5 id="LayoutInflater的基本用法"><a href="#LayoutInflater的基本用法" class="headerlink" title="LayoutInflater的基本用法"></a>LayoutInflater的基本用法</h5><p>首先看一下它的基本用法：</p>
<p>获得LayoutInflater实例有两种方法，<br>第一种：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LayoutInflater inflater = LayoutInflater.from(context);</span><br></pre></td></tr></table></figure>
<p>第二种：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</span><br></pre></td></tr></table></figure>
<p>其实第一种是第二种方法的一种简单封装，内部还是通过getSystemService去获取的。另外，LayoutInflater是一个单例。</p>
<p>使用LayoutInflater加载布局一般用这两个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public View inflate(@LayoutRes int resource, @Nullable ViewGroup root)</span><br><span class="line"></span><br><span class="line">public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot)</span><br></pre></td></tr></table></figure>
<h5 id="LayoutInflater的源码分析"><a href="#LayoutInflater的源码分析" class="headerlink" title="LayoutInflater的源码分析"></a>LayoutInflater的源码分析</h5><p>第一个参数是需要加载的布局的ID，第二个参数是加载该布局时候的外部布局，而第三个参数是指是否要将该布局添加到外部的布局上面。当然了，这个外部布局可以使空的。这里我们还是看一下具体的代码。不管你是使用的哪个inflate()方法的重载，最终都会辗转调用到LayoutInflater的如下代码中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) &#123;</span><br><span class="line">    synchronized (mConstructorArgs) &#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;inflate&quot;);</span><br><span class="line"></span><br><span class="line">        final Context inflaterContext = mContext;</span><br><span class="line">        final AttributeSet attrs = Xml.asAttributeSet(parser);</span><br><span class="line">        Context lastContext = (Context) mConstructorArgs[0];</span><br><span class="line">        mConstructorArgs[0] = inflaterContext;</span><br><span class="line">        View result = root;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            // Look for the root node.</span><br><span class="line">            int type;</span><br><span class="line">            while ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp;</span><br><span class="line">                    type != XmlPullParser.END_DOCUMENT) &#123;</span><br><span class="line">                // Empty</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (type != XmlPullParser.START_TAG) &#123;</span><br><span class="line">                throw new InflateException(parser.getPositionDescription()</span><br><span class="line">                        + &quot;: No start tag found!&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            final String name = parser.getName();</span><br><span class="line"></span><br><span class="line">            if (DEBUG) &#123;</span><br><span class="line">                System.out.println(&quot;**************************&quot;);</span><br><span class="line">                System.out.println(&quot;Creating root view: &quot;</span><br><span class="line">                        + name);</span><br><span class="line">                System.out.println(&quot;**************************&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (TAG_MERGE.equals(name)) &#123;</span><br><span class="line">                if (root == null || !attachToRoot) &#123;</span><br><span class="line">                    throw new InflateException(&quot;&lt;merge /&gt; can be used only with a valid &quot;</span><br><span class="line">                            + &quot;ViewGroup root and attachToRoot=true&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                rInflate(parser, root, inflaterContext, attrs, false);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // Temp is the root view that was found in the xml</span><br><span class="line">                final View temp = createViewFromTag(root, name, inflaterContext, attrs);</span><br><span class="line"></span><br><span class="line">                ViewGroup.LayoutParams params = null;</span><br><span class="line"></span><br><span class="line">                if (root != null) &#123;</span><br><span class="line">                    if (DEBUG) &#123;</span><br><span class="line">                        System.out.println(&quot;Creating params from root: &quot; +</span><br><span class="line">                                root);</span><br><span class="line">                    &#125;</span><br><span class="line">                    // Create layout params that match root, if supplied</span><br><span class="line">                    params = root.generateLayoutParams(attrs);</span><br><span class="line">                    if (!attachToRoot) &#123;</span><br><span class="line">                        // Set the layout params for temp if we are not</span><br><span class="line">                        // attaching. (If we are, we use addView, below)</span><br><span class="line">                        temp.setLayoutParams(params);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (DEBUG) &#123;</span><br><span class="line">                    System.out.println(&quot;-----&gt; start inflating children&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // Inflate all children under temp against its context.</span><br><span class="line">                rInflateChildren(parser, temp, attrs, true);</span><br><span class="line"></span><br><span class="line">                if (DEBUG) &#123;</span><br><span class="line">                    System.out.println(&quot;-----&gt; done inflating children&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // We are supposed to attach all the views we found (int temp)</span><br><span class="line">                // to root. Do that now.</span><br><span class="line">                if (root != null &amp;&amp; attachToRoot) &#123;</span><br><span class="line">                    root.addView(temp, params);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // Decide whether to return the root that was passed in or the</span><br><span class="line">                // top view found in xml.</span><br><span class="line">                if (root == null || !attachToRoot) &#123;</span><br><span class="line">                    result = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; catch (XmlPullParserException e) &#123;</span><br><span class="line">            final InflateException ie = new InflateException(e.getMessage(), e);</span><br><span class="line">            ie.setStackTrace(EMPTY_STACK_TRACE);</span><br><span class="line">            throw ie;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            final InflateException ie = new InflateException(parser.getPositionDescription()</span><br><span class="line">                    + &quot;: &quot; + e.getMessage(), e);</span><br><span class="line">            ie.setStackTrace(EMPTY_STACK_TRACE);</span><br><span class="line">            throw ie;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // Don&apos;t retain static reference on context.</span><br><span class="line">            mConstructorArgs[0] = lastContext;</span><br><span class="line">            mConstructorArgs[1] = null;</span><br><span class="line"></span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这这里我们可以看出，LayoutInflater其实就是使用Android提供的pull解析方式来解析文件的。其中我们发现调用了<code>createViewFromTag()</code>这个方法，接收一个rootView参数和一个属性参数，通过名字可以看出，这个方法是用来创建View对象的。跟踪这个方法，里面又调用了createView()方法，然后反射创建View实例并且返回。</p>
<p>创建完成这个根布局后，又调用<code>rInflate()</code>方法来循环遍历这个跟布局下面的所有子元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private void rInflate(XmlPullParser parser, View parent, final AttributeSet attrs)</span><br><span class="line">        throws XmlPullParserException, IOException &#123;</span><br><span class="line">    final int depth = parser.getDepth();</span><br><span class="line">    int type;</span><br><span class="line">    while (((type = parser.next()) != XmlPullParser.END_TAG ||</span><br><span class="line">            parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123;</span><br><span class="line">        if (type != XmlPullParser.START_TAG) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        final String name = parser.getName();</span><br><span class="line">        if (TAG_REQUEST_FOCUS.equals(name)) &#123;</span><br><span class="line">            parseRequestFocus(parser, parent);</span><br><span class="line">        &#125; else if (TAG_INCLUDE.equals(name)) &#123;</span><br><span class="line">            if (parser.getDepth() == 0) &#123;</span><br><span class="line">                throw new InflateException(&quot;&lt;include /&gt; cannot be the root element&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            parseInclude(parser, parent, attrs);</span><br><span class="line">        &#125; else if (TAG_MERGE.equals(name)) &#123;</span><br><span class="line">            throw new InflateException(&quot;&lt;merge /&gt; must be the root element&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            final View view = createViewFromTag(name, attrs);</span><br><span class="line">            final ViewGroup viewGroup = (ViewGroup) parent;</span><br><span class="line">            final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs);</span><br><span class="line">            rInflate(parser, view, attrs);</span><br><span class="line">            viewGroup.addView(view, params);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    parent.onFinishInflate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现其实也是调用了<code>createViewFromTag()</code>方法来创建View实例，然后又递归调用<code>rInflate()</code>方法查找View的子元素，每次递归玩成后将这个View添加到父布局中。这样，把xml中的所有View都解析完成，然后将跟布局返回，这样inflate()方法就到此结束了，而我们也得到了View对象实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inflate(int resource, ViewGroup root, boolean attachToRoot)</span><br></pre></td></tr></table></figure>
<p>我们可以通过代码解释一下这个root参数和attachroot参数的意思和用处。</p>
<p>在加载View的时候，如果root存在并且attachToRoot为false的话，View在调用<code>createViewFromTag()</code>创建的时候会把root的ViewGroup.LayoutParams当参数传递进去。那么有什么用吗？当然有用。我们知道，在View的onMeasure()方法中需要根据父布局去确定当前View的大小，除非我们指定某一确定的值为View的大小，否则在inflater一个View的时候传递空的root进去，可能得到的布局大小并不是你所想要的。这个时候你就要考虑一下这个因素的了。那么attachToRoot什么意思呢？我们看到，在它为true的时候直接调用了root.addView()将temp view添加了进去，也就是说我们加载的View会被自动添加绘制到root下面，说道这里，这俩参数什么意思应该很明确了。</p>
<h4 id="View的绘制流程"><a href="#View的绘制流程" class="headerlink" title="View的绘制流程"></a>View的绘制流程</h4><p>在创建得到一个View之后，那么显示在屏幕上的时候，显示大小，显示位置是怎么确定的呢？这就涉及到了View的绘制过程了。接下来就看一下View的绘制流程。</p>
<p>View要想显示在屏幕上面，要经过测算绘制才能显示在屏幕上面。每一个View的绘制过程都必须经过三个过程：测算，布局和绘制，即<code>onMeasure()</code>,<code>onLayout()</code>,<code>onDraw()</code>。</p>
<h5 id="onMeasure"><a href="#onMeasure" class="headerlink" title="onMeasure()"></a>onMeasure()</h5><p>通过名字我们就可以知道这个方法是用来测算View大小的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public final void measure(int widthMeasureSpec, int heightMeasureSpec)</span><br></pre></td></tr></table></figure>
<p>View的measure()方法接收两个整形参数，这两个值分贝用于确定视图的宽度和高度的规则和大小。但是他们并不是直接表示宽度和高度的，而是带有不同规格的。什么意思呢？</p>
<p>简单讲是这样的，我们知道Java中的int是32位的，<code>widthMeasureSpec</code>和<code>heightMeasureSpec</code>中的两位代表了测试模式，也就是<code>specMode</code>，剩下的才是测量的大小，即<code>specSize</code>。也就是说，<code>MeasureSpecMode</code>和<code>MeasureSpecSize</code>组成。</p>
<p>而specMode有三种：</p>
<ul>
<li>EXACTLY：精确模式，父布局提供一个精确的尺寸给这个View。无论View想要多大的尺寸，父布局给的布局边界已经确定。</li>
<li>AT_MOST：该View可以获得的最大的尺寸</li>
<li>UNSPECIFIED：父布局对该View的大小没有任何局限，View想要多大都可以。</li>
</ul>
<p>那么，<code>widthMeasureSpec</code>和<code>heightMeasureSpec</code>这两个值是从哪里来的呢？</p>
<p>我们发现，在View中还有一个<code>measure()</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123;  </span><br><span class="line">    if ((mPrivateFlags &amp; FORCE_LAYOUT) == FORCE_LAYOUT ||  </span><br><span class="line">            widthMeasureSpec != mOldWidthMeasureSpec ||  </span><br><span class="line">            heightMeasureSpec != mOldHeightMeasureSpec) &#123;  </span><br><span class="line">        mPrivateFlags &amp;= ~MEASURED_DIMENSION_SET;  </span><br><span class="line">        if (ViewDebug.TRACE_HIERARCHY) &#123;  </span><br><span class="line">            ViewDebug.trace(this, ViewDebug.HierarchyTraceType.ON_MEASURE);  </span><br><span class="line">        &#125;  </span><br><span class="line">        onMeasure(widthMeasureSpec, heightMeasureSpec);  </span><br><span class="line">        if ((mPrivateFlags &amp; MEASURED_DIMENSION_SET) != MEASURED_DIMENSION_SET) &#123;  </span><br><span class="line">            throw new IllegalStateException(&quot;onMeasure() did not set the&quot;  </span><br><span class="line">                    + &quot; measured dimension by calling&quot;  </span><br><span class="line">                    + &quot; setMeasuredDimension()&quot;);  </span><br><span class="line">        &#125;  </span><br><span class="line">        mPrivateFlags |= LAYOUT_REQUIRED;  </span><br><span class="line">    &#125;  </span><br><span class="line">    mOldWidthMeasureSpec = widthMeasureSpec;  </span><br><span class="line">    mOldHeightMeasureSpec = heightMeasureSpec;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>measure()</code>方法调用了<code>onMeasure()</code>方法去计算View大小。这个方法是一个final类型的，所以子类是无法继承重写这个方法的，说明Google并不希望开发者改变measure的流程，我们只能去改变这个计算的数值。而<code>onMeasure()</code>的源码也很简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</span><br><span class="line">            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>getDefaultSize()</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static int getDefaultSize(int size, int measureSpec) &#123;</span><br><span class="line">    int result = size;</span><br><span class="line">    int specMode = MeasureSpec.getMode(measureSpec);</span><br><span class="line">    int specSize = MeasureSpec.getSize(measureSpec);</span><br><span class="line"></span><br><span class="line">    switch (specMode) &#123;</span><br><span class="line">    case MeasureSpec.UNSPECIFIED:</span><br><span class="line">        result = size;</span><br><span class="line">        break;</span><br><span class="line">    case MeasureSpec.AT_MOST:</span><br><span class="line">    case MeasureSpec.EXACTLY:</span><br><span class="line">        result = specSize;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>getSuggestedMinimumWidth()</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected int getSuggestedMinimumHeight() &#123;</span><br><span class="line">    return (mBackground == null) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而<code>setMeasuredDimension()</code>方法最终会调用<code>setMeasuredDimensionRaw()</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private void setMeasuredDimensionRaw(int measuredWidth, int measuredHeight) &#123;</span><br><span class="line">    mMeasuredWidth = measuredWidth;</span><br><span class="line">    mMeasuredHeight = measuredHeight;</span><br><span class="line"></span><br><span class="line">    mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终我们在<code>onMeasure()</code>方法中传入的specWidth和specHeight会赋值给mMeasureWIdth和mMeasureHeight。这样View的大小就确定了。</p>
<p>那么，measure方法里面的specWidth和specHeight是从哪里来得呢？measure方法又是怎么被调用的呢？这就涉及到ViewGroup了，我们知道，任何View都是要添加到ViewGroup里面才能显示出来的，而测算View的大小也是在ViewGroup里面完成的。ViewGroup中定义了一个measureChildren()方法来去测量子视图的大小，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) &#123;  </span><br><span class="line">    final int size = mChildrenCount;  </span><br><span class="line">    final View[] children = mChildren;  </span><br><span class="line">    for (int i = 0; i &lt; size; ++i) &#123;  </span><br><span class="line">        final View child = children[i];  </span><br><span class="line">        if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123;  </span><br><span class="line">            measureChild(child, widthMeasureSpec, heightMeasureSpec);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在measureChildren()方法里面遍历了所有的View，并且调用measureChild()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">protected void measureChild(View child, int parentWidthMeasureSpec,  </span><br><span class="line">        int parentHeightMeasureSpec) &#123;  </span><br><span class="line">    final LayoutParams lp = child.getLayoutParams();  </span><br><span class="line">    final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,  </span><br><span class="line">            mPaddingLeft + mPaddingRight, lp.width);  </span><br><span class="line">    final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,  </span><br><span class="line">            mPaddingTop + mPaddingBottom, lp.height);  </span><br><span class="line">    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在第4行和第6行分别调用了getChildMeasureSpec()方法来去计算子视图的MeasureSpec，计算的依据就是布局文件中定义的MATCH_PARENT、WRAP_CONTENT等值，这个方法的内部细节就不再贴出。然后在第8行调用子视图的measure()方法，并把计算出的MeasureSpec传递进去，之后的流程就和前面所介绍的一样了。</p>
<p>这样，View绘制流程的第一步就完成了。</p>
<h5 id="onLayout"><a href="#onLayout" class="headerlink" title="onLayout()"></a>onLayout()</h5><p>measure过程结束后，View的大小就已经测量好了，接下来就是layout的过程了。这个方法是用于给View进行布局的，也就是确定View的位置。View的onMeasure和onLayout的调用都是在ViewRootImpl的performTraversals()方法中，在onMeasure()方法执行完成后还会接着调用View的layout()。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 这段代码存在于performLayout()方法中</span><br><span class="line">host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight());</span><br></pre></td></tr></table></figure>
<p>layout()方法接收四个参数，分别代表左上右下的坐标，需要注意的是这里的坐标值都是相对于当前的父布局来说的，是相对坐标。host代表的就是当前的View。所以这里的<code>host.getMeasuredWidth()</code>和<code>host.getMeasuredHeight()</code>就是上一步中测算出来的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public void layout(int l, int t, int r, int b) &#123;</span><br><span class="line">        if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) &#123;</span><br><span class="line">            onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);</span><br><span class="line">            mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int oldL = mLeft;</span><br><span class="line">        int oldT = mTop;</span><br><span class="line">        int oldB = mBottom;</span><br><span class="line">        int oldR = mRight;</span><br><span class="line"></span><br><span class="line">        boolean changed = isLayoutModeOptical(mParent) ?</span><br><span class="line">                setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</span><br><span class="line"></span><br><span class="line">        if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</span><br><span class="line">            onLayout(changed, l, t, r, b);</span><br><span class="line"></span><br><span class="line">            if (shouldDrawRoundScrollbar()) &#123;</span><br><span class="line">                if(mRoundScrollbarRenderer == null) &#123;</span><br><span class="line">                    mRoundScrollbarRenderer = new RoundScrollbarRenderer(this);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                mRoundScrollbarRenderer = null;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;</span><br><span class="line"></span><br><span class="line">            ListenerInfo li = mListenerInfo;</span><br><span class="line">            if (li != null &amp;&amp; li.mOnLayoutChangeListeners != null) &#123;</span><br><span class="line">                ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =</span><br><span class="line">                        (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();</span><br><span class="line">                int numListeners = listenersCopy.size();</span><br><span class="line">                for (int i = 0; i &lt; numListeners; ++i) &#123;</span><br><span class="line">                    listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;</span><br><span class="line">        mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法中，会先调用<code>setFrame()</code>方法来判断View的大小是否已经发生了变化。同时还会在这里把传递过来的四个参数分别赋值给mLeft、mTop、mRight和mBottom这几个变量。接下来就会调用<code>onLayout()</code>，这个方法在View中是一个空方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为一个View的布局是由父布局完成的，所以这个方法已经在<code>ViewGroup</code>中来实现。我们知道<code>ViewGroup</code>是所有布局的父类，而<code>onLayout()</code>也是一个抽象方法，所以这个方法会在<code>LinearLayout</code>等子类来实现的。所以一般来说，如果我们要自定义一个View是不需要重写这个方法的，当我们需要自定义一个布局的时候才会用到它。比如我们需要一个侧滑布局-<code>DrawerLayout</code>。</p>
<p>在五个布局中，<code>FrameLayout</code>是最简单的一个布局，我们可以看一下这个代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123;</span><br><span class="line">    layoutChildren(left, top, right, bottom, false /* no force left gravity */);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">void layoutChildren(int left, int top, int right, int bottom, boolean forceLeftGravity) &#123;</span><br><span class="line">        final int count = getChildCount();</span><br><span class="line"></span><br><span class="line">        final int parentLeft = getPaddingLeftWithForeground();</span><br><span class="line">        final int parentRight = right - left - getPaddingRightWithForeground();</span><br><span class="line"></span><br><span class="line">        final int parentTop = getPaddingTopWithForeground();</span><br><span class="line">        final int parentBottom = bottom - top - getPaddingBottomWithForeground();</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">            final View child = getChildAt(i);</span><br><span class="line">            if (child.getVisibility() != GONE) &#123;</span><br><span class="line">                final LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">                final int width = child.getMeasuredWidth();</span><br><span class="line">                final int height = child.getMeasuredHeight();</span><br><span class="line"></span><br><span class="line">                int childLeft;</span><br><span class="line">                int childTop;</span><br><span class="line"></span><br><span class="line">                int gravity = lp.gravity;</span><br><span class="line">                if (gravity == -1) &#123;</span><br><span class="line">                    gravity = DEFAULT_CHILD_GRAVITY;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                final int layoutDirection = getLayoutDirection();</span><br><span class="line">                final int absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection);</span><br><span class="line">                final int verticalGravity = gravity &amp; Gravity.VERTICAL_GRAVITY_MASK;</span><br><span class="line"></span><br><span class="line">                switch (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123;</span><br><span class="line">                    case Gravity.CENTER_HORIZONTAL:</span><br><span class="line">                        childLeft = parentLeft + (parentRight - parentLeft - width) / 2 +</span><br><span class="line">                        lp.leftMargin - lp.rightMargin;</span><br><span class="line">                        break;</span><br><span class="line">                    case Gravity.RIGHT:</span><br><span class="line">                        if (!forceLeftGravity) &#123;</span><br><span class="line">                            childLeft = parentRight - width - lp.rightMargin;</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line">                    case Gravity.LEFT:</span><br><span class="line">                    default:</span><br><span class="line">                        childLeft = parentLeft + lp.leftMargin;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                switch (verticalGravity) &#123;</span><br><span class="line">                    case Gravity.TOP:</span><br><span class="line">                        childTop = parentTop + lp.topMargin;</span><br><span class="line">                        break;</span><br><span class="line">                    case Gravity.CENTER_VERTICAL:</span><br><span class="line">                        childTop = parentTop + (parentBottom - parentTop - height) / 2 +</span><br><span class="line">                        lp.topMargin - lp.bottomMargin;</span><br><span class="line">                        break;</span><br><span class="line">                    case Gravity.BOTTOM:</span><br><span class="line">                        childTop = parentBottom - height - lp.bottomMargin;</span><br><span class="line">                        break;</span><br><span class="line">                    default:</span><br><span class="line">                        childTop = parentTop + lp.topMargin;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                child.layout(childLeft, childTop, childLeft + width, childTop + height);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这段代码不是很复杂，就是首先获取<code>FrameLayout</code>的<code>Padding</code>值计算出<code>FrameLayout</code>内容可以使用的空间大小，然后通过遍历每一个View，根据它的<code>Gravity</code>，<code>margin</code>属性计算出View的位置。在方法最后将值回调给<code>child.layout()</code>，View可以根据自己需要再次更改</p>
<p>到此为止，我们把视图绘制流程的第二阶段也分析完了。</p>
<h5 id="onDraw"><a href="#onDraw" class="headerlink" title="onDraw()"></a>onDraw()</h5><p>measure和layout的过程都结束后，接下来就进入到draw的过程了。同样，根据名字你就能够判断出，在这里才真正地开始对视图进行绘制。ViewRootImpl中的代码会继续执行并创建出一个Canvas对象，然后调用View的draw()方法来执行具体的绘制工作。draw()方法内部的绘制过程总共可以分为六步，其中第二步和第五步在一般情况下很少用到，因此这里我们只分析简化后的绘制过程。代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public void draw(Canvas canvas) &#123;  </span><br><span class="line">    if (ViewDebug.TRACE_HIERARCHY) &#123;  </span><br><span class="line">        ViewDebug.trace(this, ViewDebug.HierarchyTraceType.DRAW);  </span><br><span class="line">    &#125;  </span><br><span class="line">    final int privateFlags = mPrivateFlags;  </span><br><span class="line">    final boolean dirtyOpaque = (privateFlags &amp; DIRTY_MASK) == DIRTY_OPAQUE &amp;&amp;  </span><br><span class="line">            (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState);  </span><br><span class="line">    mPrivateFlags = (privateFlags &amp; ~DIRTY_MASK) | DRAWN;  </span><br><span class="line">    // Step 1, draw the background, if needed  </span><br><span class="line">    int saveCount;  </span><br><span class="line">    if (!dirtyOpaque) &#123;  </span><br><span class="line">        final Drawable background = mBGDrawable;  </span><br><span class="line">        if (background != null) &#123;  </span><br><span class="line">            final int scrollX = mScrollX;  </span><br><span class="line">            final int scrollY = mScrollY;  </span><br><span class="line">            if (mBackgroundSizeChanged) &#123;  </span><br><span class="line">                background.setBounds(0, 0,  mRight - mLeft, mBottom - mTop);  </span><br><span class="line">                mBackgroundSizeChanged = false;  </span><br><span class="line">            &#125;  </span><br><span class="line">            if ((scrollX | scrollY) == 0) &#123;  </span><br><span class="line">                background.draw(canvas);  </span><br><span class="line">            &#125; else &#123;  </span><br><span class="line">                canvas.translate(scrollX, scrollY);  </span><br><span class="line">                background.draw(canvas);  </span><br><span class="line">                canvas.translate(-scrollX, -scrollY);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    final int viewFlags = mViewFlags;  </span><br><span class="line">    boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != 0;  </span><br><span class="line">    boolean verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != 0;  </span><br><span class="line">    if (!verticalEdges &amp;&amp; !horizontalEdges) &#123;  </span><br><span class="line">        // Step 3, draw the content  </span><br><span class="line">        if (!dirtyOpaque) onDraw(canvas);  </span><br><span class="line">        // Step 4, draw the children  </span><br><span class="line">        dispatchDraw(canvas);  </span><br><span class="line">        // Step 6, draw decorations (scrollbars)  </span><br><span class="line">        onDrawScrollBars(canvas);  </span><br><span class="line">        // we&apos;re done...  </span><br><span class="line">        return;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，第一步是从第9行代码开始的，这一步的作用是对视图的背景进行绘制。这里会先得到一个mBGDrawable对象，然后根据layout过程确定的视图位置来设置背景的绘制区域，之后再调用Drawable的draw()方法来完成背景的绘制工作。那么这个mBGDrawable对象是从哪里来的呢？其实就是在XML中通过android:background属性设置的图片或颜色。当然你也可以在代码中通过setBackgroundColor()、setBackgroundResource()等方法进行赋值。<br>接下来的第三步是在第34行执行的，这一步的作用是对视图的内容进行绘制。可以看到，这里去调用了一下onDraw()方法，那么onDraw()方法里又写了什么代码呢？进去一看你会发现，原来又是个空方法啊。其实也可以理解，因为每个视图的内容部分肯定都是各不相同的，这部分的功能交给子类来去实现也是理所当然的。<br>第三步完成之后紧接着会执行第四步，这一步的作用是对当前视图的所有子视图进行绘制。但如果当前的视图没有子视图，那么也就不需要进行绘制了。因此你会发现View中的dispatchDraw()方法又是一个空方法，而ViewGroup的dispatchDraw()方法中就会有具体的绘制代码。<br>最后还会绘制一个滚动条，所以，我们可以知道不只是<code>srcollview</code>或者<code>recyclerView</code>这类的View，任何一个View都有一个滚动条，只是它默认没有开启罢了。<br>我们可以在<code>canvas</code>上面绘制我们想要的任何试图。具体<code>canvas</code>是有许多方法的，可以参考<a href="https://developer.android.com/reference/android/graphics/Canvas.html" target="_blank" rel="noopener">官网文档</a>去学习。</p>
<h4 id="实战应用-实现两端对齐的TextView"><a href="#实战应用-实现两端对齐的TextView" class="headerlink" title="实战应用-实现两端对齐的TextView"></a>实战应用-实现两端对齐的TextView</h4><p> 记得产品之前提了一个需求，要我们实现类似于微信聊天窗口那样的文本对齐方式-两端对齐。这个在android原生的API里面并没有提供，先看下效果:</p>
<p><img src="http://7xjtan.com1.z0.glb.clouddn.com/WechatIMG268.jpeg" alt=""></p>
<p>我们发现，微信通过调整文字之间的间距来保证每一行文字的左右端都是对齐的状态的，这样文字看起来就会整齐很多。我们要实现这种效果就要自定义一个TextView，在onDraw()方法中处理每一个文字之间的间隔。思路大概这样:</p>
<ul>
<li>将一篇文章按段落分成若干段</li>
<li>将每一段的文字拆分成各个单词，然后根据控件长度确定每一行最多可以填入的单词数，并且算出排满该行还需要填入多大的间距</li>
<li>将间距平均填充到文字之间</li>
</ul>
<p>主要涉及<code>onDraw()</code>方法和<code>calc()</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">        TextPaint paint = getPaint();</span><br><span class="line">        paint.setColor(getCurrentTextColor());</span><br><span class="line">        paint.drawableState = getDrawableState();</span><br><span class="line"></span><br><span class="line">        width = getMeasuredWidth();</span><br><span class="line"></span><br><span class="line">        Paint.FontMetrics fm = paint.getFontMetrics();</span><br><span class="line">        float firstHeight = getTextSize() - (fm.bottom - fm.descent + fm.ascent - fm.top);</span><br><span class="line"></span><br><span class="line">        int gravity = getGravity();</span><br><span class="line">        if ((gravity &amp; 0x1000) == 0) &#123; // 是否垂直居中</span><br><span class="line">            firstHeight = firstHeight + (textHeight - firstHeight) / 2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int paddingTop = getPaddingTop();</span><br><span class="line">        int paddingLeft = getPaddingLeft();</span><br><span class="line">        int paddingRight = getPaddingRight();</span><br><span class="line">        width = width - paddingLeft - paddingRight;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; lines.size(); i++) &#123;</span><br><span class="line">            float drawY = i * textHeight + firstHeight;</span><br><span class="line">            String line = lines.get(i);</span><br><span class="line">            // 绘画起始x坐标</span><br><span class="line">            float drawSpacingX = paddingLeft;</span><br><span class="line">            float gap = (width - paint.measureText(line));</span><br><span class="line">            float interval = gap / (line.length() - 1);</span><br><span class="line"></span><br><span class="line">            // 绘制最后一行</span><br><span class="line">            if (tailLines.contains(i)) &#123;</span><br><span class="line">                interval = 0;</span><br><span class="line">                if (align == Align.ALIGN_CENTER) &#123;</span><br><span class="line">                    drawSpacingX += gap / 2;</span><br><span class="line">                &#125; else if (align == Align.ALIGN_RIGHT) &#123;</span><br><span class="line">                    drawSpacingX += gap;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            for (int j = 0; j &lt; line.length(); j++) &#123;</span><br><span class="line">                float drawX = paint.measureText(line.substring(0, j)) + interval * j;</span><br><span class="line">                canvas.drawText(line.substring(j, j + 1), drawX + drawSpacingX, drawY +</span><br><span class="line">                        paddingTop + textLineSpaceExtra * i, paint);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 计算每行应显示的文本数</span><br><span class="line">     *</span><br><span class="line">     * @param text 要计算的文本</span><br><span class="line">     */</span><br><span class="line">    private void calc(Paint paint, String text) &#123;</span><br><span class="line">        if (text.length() == 0) &#123;</span><br><span class="line">            lines.add(&quot;\n&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        int startPosition = 0; // 起始位置</span><br><span class="line">        float oneChineseWidth = paint.measureText(&quot;中&quot;);</span><br><span class="line">        int ignoreCalcLength = (int) (width / oneChineseWidth); // 忽略计算的长度</span><br><span class="line">        StringBuilder sb = new StringBuilder(text.substring(0, Math.min(ignoreCalcLength + 1,</span><br><span class="line">                text.length())));</span><br><span class="line"></span><br><span class="line">        for (int i = ignoreCalcLength + 1; i &lt; text.length(); i++) &#123;</span><br><span class="line">            if (paint.measureText(text.substring(startPosition, i + 1)) &gt; width) &#123;</span><br><span class="line">                startPosition = i;</span><br><span class="line">                //将之前的字符串加入列表中</span><br><span class="line">                lines.add(sb.toString());</span><br><span class="line"></span><br><span class="line">                sb = new StringBuilder();</span><br><span class="line"></span><br><span class="line">                //添加开始忽略的字符串，长度不足的话直接结束,否则继续</span><br><span class="line">                if ((text.length() - startPosition) &gt; ignoreCalcLength) &#123;</span><br><span class="line">                    sb.append(text.substring(startPosition, startPosition + ignoreCalcLength));</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    lines.add(text.substring(startPosition));</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                i = i + ignoreCalcLength - 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                sb.append(text.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (sb.length() &gt; 0) &#123;</span><br><span class="line">            lines.add(sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tailLines.add(lines.size() - 1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>看一下实现的效果，上面是系统自带的效果，下面使我们实现的效果:</p>
<p><img src="http://7xjtan.com1.z0.glb.clouddn.com/Jietu20171206-195250.jpg" alt=""></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>View是我们日常开发中用到的频率很高的一部分，要掌握好了绘制的基本流程以及一些canvas的基本方法，对于三大流程<code>onMeasure()</code>，<code>onLayout()</code>以及<code>onDraw()</code>，我们要很熟悉他的调用流程以及每个方法的作用，这样很多效果实现起来就比较简单了。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Android/" rel="tag"># Android</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/08/13/android-AIDLTwo/" rel="next" title="Android跨进程通信机制(二)">
                <i class="fa fa-chevron-left"></i> Android跨进程通信机制(二)
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/10/14/练手系列-Kotlin实现JSBridge/" rel="prev" title="练手系列-Kotlin实现JSBridge">
                练手系列-Kotlin实现JSBridge <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Jimbo</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">36</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/bornbeauty" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="zhongjinbao1994@gmail.com" target="_blank" title="email">
                      
                        <i class="fa fa-fw fa-envelope"></i>email</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://plus.google.com/yourname" target="_blank" title="Google">
                      
                        <i class="fa fa-fw fa-google"></i>Google</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/zhongjinbao1994" target="_blank" title="微博">
                      
                        <i class="fa fa-fw fa-weibo"></i>微博</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://stackoverflow.com/users/6255622/%E9%92%9F%E9%87%91%E5%AE%9D" target="_blank" title="StackOverflow">
                      
                        <i class="fa fa-fw fa-stack-overflow"></i>StackOverflow</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#从LayoutInflater讲起"><span class="nav-number">2.</span> <span class="nav-text">从LayoutInflater讲起</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#LayoutInflater的基本用法"><span class="nav-number">2.1.</span> <span class="nav-text">LayoutInflater的基本用法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#LayoutInflater的源码分析"><span class="nav-number">2.2.</span> <span class="nav-text">LayoutInflater的源码分析</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#View的绘制流程"><span class="nav-number">3.</span> <span class="nav-text">View的绘制流程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#onMeasure"><span class="nav-number">3.1.</span> <span class="nav-text">onMeasure()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#onLayout"><span class="nav-number">3.2.</span> <span class="nav-text">onLayout()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#onDraw"><span class="nav-number">3.3.</span> <span class="nav-text">onDraw()</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实战应用-实现两端对齐的TextView"><span class="nav-number">4.</span> <span class="nav-text">实战应用-实现两端对齐的TextView</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结"><span class="nav-number">5.</span> <span class="nav-text">总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jimbo</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
